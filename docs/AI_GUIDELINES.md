# GNSSLIB 프로젝트 AI 작업 가이드라인

이 문서는 GNSSLIB 프로젝트에서 AI가 코드 작성, 문서화, 리팩토링 등의 작업을 수행할 때 지켜야 할 규칙들을 정의합니다.

## 목차

1. [기본 원칙](#1-기본-원칙)
   - 1.1 [언어 및 소통](#11-언어-및-소통)
   - 1.2 [플랫폼 호환성](#12-플랫폼-호환성)

2. [C 언어 코딩 스타일](#2-c-언어-코딩-스타일)
   - 2.1 [네이밍 컨벤션](#21-네이밍-컨벤션)
   - 2.2 [구조체 정의](#22-구조체-정의)
   - 2.3 [헤더 파일 관리](#23-헤더-파일-관리)

3. [문서화 규칙](#3-문서화-규칙)
   - 3.1 [마크다운 문서](#31-마크다운-문서)
   - 3.2 [수학 표기법](#32-수학-표기법)
   - 3.3 [함수 문서화 분리](#33-함수-문서화-분리)

4. [코드 품질 관리](#4-코드-품질-관리)
   - 4.1 [코드 구조](#41-코드-구조)
   - 4.2 [컴파일 및 검증](#42-컴파일-및-검증)
   - 4.3 [리팩토링 원칙](#43-리팩토링-원칙)
   - 4.4 [메모리 관리](#44-메모리-관리)

5. [예외 처리 및 디버깅](#5-예외-처리-및-디버깅)
   - 5.1 [오류 처리](#51-오류-처리)
   - 5.2 [코드 가독성](#52-코드-가독성)

---

## 1. 기본 원칙

### 1.1 언어 및 소통
- **항상 한국어로 응답**
- 협업에서 통용되는 관행을 따름
- 효율적이고 간결하고 우아한 방식을 추구

### 1.2 플랫폼 호환성
- **Windows, Mac, Linux 모두 호환** 가능한 코드 작성
- C 표준 라이브러리 우선 사용
- 플랫폼별 조건부 컴파일 필요시 적절히 활용

## 2. C 언어 코딩 스타일

### 2.1 네이밍 컨벤션
```c
// Functions: PascalCase
void InitNav(nav_t *nav);
int Prn2Sat(int sys, int prn);

// Variables: camelCase or lowercase
int satIndex, matrixData, nsat;

// Constants: UPPER_SNAKE_CASE
#define MAX_PRN_GPS 32
#define FREQ_L1 1575.42e6

// Structures/Types: camelCase + _t suffix
typedef struct leapSec {
    // ...
} leapSec_t;

typedef struct satStr {
    char str[SAT_STR_SIZE];
} satStr_t;
```

### 2.2 구조체 정의 및 타입 관리
- 멤버 변수는 적절한 들여쓰기와 정렬로 가독성 확보
- 주석은 각 멤버의 역할과 단위를 명시
- 기본값 초기화는 구조체 정의가 아닌 사용 시점에서 수행
- **구조체 위치 규칙**:
  - GNSS library 전체에서 사용되는 구조체 → `types.h`에 정의
  - 특정 소스 파일에서만 사용되는 구조체 → 해당 소스 파일 내 정의

### 2.3 헤더 파일 관리
- **순환 참조 절대 금지**
- 헤더에는 선언에 필요한 최소한의 헤더만 포함
- 구현 파일로 가능한 많은 헤더 이동
- **헤더 include 순서 및 형식**:
```c
// Standard library
#include <stdio.h>
#include <stdlib.h>

// GNSS library
#include "types.h"          // for types
#include "common.h"         // for utility functions
```

### 2.4 함수 선언과 정의 위치
- **공개 함수**: 헤더에 선언, 해당 소스에 정의
- **내부 함수**: `static` 키워드로 소스 파일 내부에만 선언/정의
- **inline 함수**: 헤더에 `static inline`으로 정의 (성능 중요한 간단한 함수)

### 2.5 상수 정의 위치
- **전역 상수**: `const.h`에 `#define`으로 정의
- **모듈별 상수**: 해당 헤더 파일에 `#define`으로 정의
- **파일 내부 상수**: 소스 파일에 `static const` 또는 `#define`으로 정의
- 소스 구현 시 사용되는 매크로도 소스 파일에 명시

### 2.6 소스 파일 헤더 관리
- 소스 구현 시 필요한 헤더 추가
- 주석으로 어떤 용도로 사용하는지 간략히 명시
- Standard library와 GNSS library를 주석으로 구분

### 2.7 헤더 가드 및 C++ 호환성
```c
#ifndef HEADER_NAME_H
#define HEADER_NAME_H

#ifdef __cplusplus
extern "C" {
#endif

// 헤더 내용

#ifdef __cplusplus
}
#endif

#endif // HEADER_NAME_H
```

### 2.8 에러 처리 및 반환값
- **성공/실패**: `int` 반환 (1: 성공, 0: 실패)
- **포인터 반환**: `NULL` 체크 필수
- **매개변수 검증**: 공개 함수에서는 입력 매개변수 유효성 검사

### 2.9 메모리 관리
- **할당/해제 쌍**: `InitXxx`/`FreeXxx` 함수 쌍으로 관리
- **동적 할당**: 항상 해제 함수 제공
- **구조체 초기화**: 모든 멤버 명시적 초기화

### 2.10 순환 의존성 방지
- `types.h` → `const.h`만 의존
- 다른 헤더들 → `types.h` 의존
- 복잡한 의존성은 전방 선언 활용

### 2.11 컴파일러 호환성
- C99 표준 준수
- Windows/Mac/Linux 호환성 고려
- 컴파일러 경고 최소화

## 3. 문서화 규칙

### 3.1 마크다운 문서
- **C코드에 해당하는 마크다운 Docs 작성 필수**
- **해당 C코드 또는 헤더에 포함된 내용만 작성 → 없는 내용은 작성 금지**
- 제목 단계에 따라 특수문자가 아닌 숫자 다단계 이용
- 목차와 최상위 제목은 특수문자 없이 글만 작성(파일 명 표시를 위한 괄호는 허용)
- 이모티콘 사용 금지
- **인라인 수식은 `$...$` 형식** 사용 (LaTeX 호환성)
- 내용 순서는 목차 → 기본 개념 → 데이터 타입 트리 구조 → 데이터 타입 목록 → 함수 트리 구조 → 함수 목록 → 사용 예시 → 성능 특성 순으로 작성
- 기본 개념은 해당 코드의 구조나 방식, 특징을 기입 (수식 필요 시 적절히 사용) (예: column major 저장방식, 메모리 관리 체계, 위성 인덱스 시스템, GNSS 관측 코드 구조, 인덱스 매핑 시스템, 설계 철학 등)

#### 데이터 타입 트리 구조 규칙
```
## 2. 데이터 타입 구조

모듈명 타입 계층
├── 주요 카테고리 1
│   ├── type1_t ──────────── 타입 간단 설명
│   ├── type2_t ──────────── 타입 간단 설명
│   └── type3_t ──────────── 타입 간단 설명
├── 주요 카테고리 2
│   ├── typeA_t ──────────── 타입 간단 설명
│   └── typeB_t ──────────── 타입 간단 설명
└── 기타 관련 데이터
    ├── 배열[SIZE] ────────── 배열 형태 데이터
    └── 기본 타입 ──────────── int, double 등
```

**규칙**:
- ASCII 트리 구조로 계층 관계 표현
- 들여쓰기는 │, ├, └ 문자 사용
- 타입명 뒤에 ─ 문자로 정렬하여 설명 추가
- 간단 설명의 시작 위치를 동일한 열로 정렬
- 관련 있는 타입들을 카테고리별로 그룹핑
- 구조체는 `type_t` 형태, 배열은 `배열[SIZE]` 형태로 표기

#### 함수 트리 구조 규칙
```
## 4. 함수 구조

모듈명 함수 계층
├── 주요 기능 카테고리 1
│   ├── Function1() ──────── 함수 간단 설명
│   ├── Function2() ──────── 함수 간단 설명
│   └── Function3() ──────── 함수 간단 설명
├── 주요 기능 카테고리 2
│   ├── 세부 기능 그룹
│   │   ├── FuncA() ──────── 함수 간단 설명
│   │   ├── FuncB() ──────── 함수 간단 설명
│   │   └── FuncC() ──────── 함수 간단 설명
│   └── 기타 함수
│       ├── FuncX() ──────── 함수 간단 설명
│       └── FuncY() ──────── 함수 간단 설명
└── 유틸리티 함수
    ├── UtilFunc1() ──────── 함수 간단 설명
    └── UtilFunc2() ──────── 함수 간단 설명
```

**규칙**:
- ASCII 트리 구조로 기능별 계층 관계 표현
- 들여쓰기는 │, ├, └ 문자 사용
- 함수명 뒤에 ─ 문자로 정렬하여 설명 추가
- (static) 함수일 경우 설명 오른쪽에 (static) 추가
- 간단 설명의 시작 위치를 동일한 열로 정렬
- 관련 기능별로 카테고리 그룹핑
- 세부 기능이 많은 경우 하위 그룹으로 세분화
- 함수명은 `Function()` 형태로 괄호 포함

#### 데이터 타입 목록 구조화 규칙
```
## 3. 데이터 타입 목록

### 3.1 type_t (enum) - 행렬 타입 구조체
<details>
<summary>상세 설명</summary>

**목적**: ...
**정의**: ...
**값**: ... 또는 **특징**: ...
**사용**: ... 또는 **접근 함수**: ...

</details>
```

#### 함수 목록 구조화 규칙
```
## 5. 함수 목록

### 5.1 기본 생성/해제 함수

#### Mat() - 행렬 생성
<details>
<summary>상세 설명</summary>

**목적**: ...
**입력**: ...
**출력**: ...
**함수 로직**: ...  내용에 따라 수식 또는 코드 블록 이용
**사용 예시**: ...

</details>
```

### 3.2 수학 표기법
- **벡터**: 소문자 + 볼드 + 이탤릭 → `$\boldsymbol{a}$`
- **스칼라**: 소문자 + 이탤릭 → `$a$`
- **행렬**: 대문자 + 볼드 → `$\mathbf{A}$`
- **영어 단어 변수**: `$\text{GPST}$`, `$\text{week}$`, `$\text{tow}$`

>**예시**: 위성-수신기 간 거리 계산 공식
>
> $$\rho_r^s = \sqrt{(x_s - x_r)^2 + (y_s - y_r)^2 + (z_s - z_r)^2} + \frac{\omega_e}{c}\cdot(x^sy_r-x_ry^s) $$
>
> **변수 설명:**
> - $\rho_r^s$: 위성-수신기 간 거리
> - $\boldsymbol{r}^s = [x^s, y^s, z^s]^{\top}$: 위성 위치 벡터
> - $\boldsymbol{r}_r = [x_r, y_r, z_r]^{\top}$: 수신기 위치 벡터
> - $c$: 광속
> - $\omega_e$: 지구 자전 속도




## 4. 코드 품질 관리

### 4.1 코드 구조
- 가독성, 직관성 효율성을 적절히 고려할 것
- **성능보다 안정성 우선**

### 4.2 컴파일 및 검증
- 변경 후 반드시 컴파일 검증
- 경고 메시지 최소화
- 오류 발생 시 3회 이내 수정 시도

### 4.3 리팩토링 원칙
- 기능 변경 없이 구조 개선
- 단계적 접근 (한 번에 하나의 모듈)
- 순환 참조 해결 우선

### 4.4 메모리 관리
- 동적 할당 시 반드시 해제 함수 제공
- 초기화 함수와 해제 함수 쌍으로 설계
- NULL 포인터 검증 철저히 수행

## 5. 예외 처리 및 디버깅

### 5.1 오류 처리
- 함수 반환값으로 성공/실패 상태 전달
- 인덱스류 (sat, rcv, band, code, ...) 반환 함수 → 0: 오류
- double 반환 함수 → 0.0: 오류
- 포인터류 반환 함수 → NULL: 오류
- **위 규칙을 지키지 못하는 경우 함수 설명 주석에 기입 필수**
- 입력 검증을 통한 방어적 프로그래밍

### 5.2 코드 가독성
- 복잡한 로직은 주석으로 설명
- 매직 넘버 대신 명명된 상수 사용
- 함수는 하나의 책임만 가지도록 설계

---

**이 가이드라인은 GNSSLIB 프로젝트의 일관성과 품질를 보장하기 위한 필수 규칙입니다.**
**모든 AI 작업은 이 규칙을 준수하여 수행되어야 합니다.**
